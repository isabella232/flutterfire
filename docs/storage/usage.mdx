---
title: Using Cloud Storage
sidebar_label: Usage
---

To start using the Cloud Firestore package within your project, import it at the top of your project files:

```dart
import 'package:firebase_storage/firebase_storage.dart';
```

Before using Firebase Storage, you must first have ensured you have [initialized FlutterFire](overview#initializing-flutterfire).

To create a new Storage instance, call the instance getter on `FirebaseStorage`:

```dart
FirebaseStorage storage = FirebaseStorage.instance;
```

By default, this allows you to interact with Storage using the default Firebase App used whilst installing FlutterFire on your platform.
If however you'd like to use Storage with a secondary Firebase App, use the `instanceFor` method:

```dart
FirebaseApp secondaryApp = Firebase.app('SecondaryApp');
FirebaseStorage storage = FirebaseStorage.instanceFor(app: secondaryApp);
```

It is also possible to specify a non-default Storage bucket which you may have created in your Firebase project (see below). To connect to a
different bucket, provide the name to the `instanceFor` method:

```dart
FirebaseStorage storage = FirebaseStorage.instanceFor(bucket: 'secondary-storage-bucket');
```

If no `app` argument is provided to the `instanceFor` method, the default app will be used.

### Create additional storage buckets

If you haven't already done so, you first need to create the default storage bucket on the [Firebase console](https://console.firebase.google.com/project/_/storage).

Firebase provides the ability to create mutliple buckets per project. Creating additional storage buckets is recommended to separate unrelated files for your project
(such as database backups) however are not required to successfully use Firebase Storage.

You can create a new bucket by visiting the Firebase console. For more information, visit the [official documentataion](https://firebase.google.com/docs/storage/web/start#create-default-bucket).

## References

A reference is a pointer to a file within your specified storage bucket. This can be a file that already exists,
or for one that does not exist yet.

To create a reference, use the [`ref`](!firebase_storage.FirebaseStorage.ref) method on a `FirebaseStorage` instance:

```dart
final Reference ref = FirebaseStorage.instance.ref('/notes.txt');
```

A reference can also be a nested file or directory. Provide the full path or use the [`child`](!firebase_storage.Reference.child) method on the
returned reference:

```dart
final Reference ref = FirebaseStorage.instance.ref('images/defaultProfile.png');
// or
final Reference ref = FirebaseStorage.instance.ref().child('images').child('defaultProfile.png');
```

When no argument to `ref` is provided, the root of the storage bucket will be used as the reference.

## Listing files & directories

Firebase provides the ability to list the files and directories within a directory. There are two methods available
which provide this ability; [`list`](!firebase_storage.Reference.list) & [`listAll`](!firebase_storage.Reference.listAll). Both methods
return a [`ListResult`](!firebase_storage.ListResult) which contains any files, directories and pagination tokens from the request.

For example, to view all files and directories within the root of the default storage bucket:

```dart
ListResult result = await FirebaseStorage.instance.ref().listAll();

result.items.forEach((Reference ref) {
  print('Found file: $ref');
});

result.prefixes.forEach((Reference ref) {
  print('Found directory: $ref');
});
```

The `items` property represents a file within the bucket, and the `prefixes` property represents nested directories.

In cases where you have a large volume of files and directories, calling `listAll` may take a long time to return
all results. In this case, calling `list` and limiting the results may result in a better user experience:

```dart
ListResult result = await FirebaseStorage.instance.ref().list(ListOptions(maxResults: 10));
```

The [`ListOptions`](firebase_storage_platform_interface.ListOptions) instance provided to `list`
allows us to limit the number of results returned. It also accepts an optional `pageToken` argument
which can be used to paginate any additional results not returned in the listing, for example:

```dart
ListResult result = await FirebaseStorage.instance.ref().list(ListOptions(maxResults: 10));

if (result.nextPageToken != null) {
  ListResult additionalResults = await FirebaseStorage.instance.ref()
    .list(ListOptions(
      maxResults: 10,
      pageToken: result.nextPageToken,
    ));
}
```

## Download URLs

In many use-cases, you may wish to display images stored on a storage bucket within your application, using
Firebase as a scalable and cost-effective Content Distribution Network (CDN). Firebase allows you to
retrieve a long-lived download URL which can be used. To request a download URL, call the
[`downloadURL`](!firebase_storage.Reference.downloadURL) method on a reference:

```dart
String downloadURL = await FirebaseStorage.instance.ref('users/123/avatar.jpg').getDownloadURL();

// Within your widgets:
Image.network(downloadURL);
```

## Uploading Files

FlutterFire supports uploading a variety of file types to Firebase Storage, such a raw string values or
on-device files.

### File uploads

To upload a file, you must first create an absolute path to it's on-device location. For example, if a file exists within the
applications documnents directory, we can use the official [`path_provider`](https://pub.dev/packages/path_provider) package
to generate a file path:

```dart
import 'package:path_provider/path_provider.dart';

Directory appDocDir = await getApplicationDocumentsDirectory();
String filePath = '${appDocDir.absolute}/file-to-upload.png';
```

Once your absolute path has been created, it can be passed as a [`File`](https://api.flutter.dev/flutter/dart-io/File-class.html)
instance to the [`putFile`](!firebase_storage.Reference.putFile) method:

```dart
File file = File(filePath);
UploadTask task = FirebaseStorage.instance.ref('uploads/file-to-upload.png').putFile(file);

try {
  await task.onComplete;
} catch (e) {
  print(e);
}
```

To learn more about tasks, view the [Handling Tasks](#handling-tasks) documentataion.

### Upload from a String

It is possible to upload a raw, `base64`, `base64url`, or `data_url` encoded string to Firebase Storage using the
[`putString`](!firebase_storage.Reference.putString) method. For example, to upload a text string encoded as a Data URL:

```dart
String dataUrl = 'data:text/plain;base64,SGVsbG8sIFdvcmxkIQ==';
UploadTask task = FirebaseStorage.instance.ref('uploads/hello-world.text')
  .putString(dataUrl, format: PutStringFormat.dataUrl);

try {
  await task.onComplete;
} catch (e) {
  print(e);
}
```

To learn more about tasks, view the [Handling Tasks](#handling-tasks) documentataion.

### Uploading raw data

FlutterFire also supports uploading lowerlevel typed data in the form of a [`Uint8List`](https://api.dart.dev/stable/2.9.2/dart-typed_data/Uint8List-class.html)
for those cases where uploading a string or `File` is not practical. In this case, call the [`putData`](!firebase_storage.Reference.putData)
method with your data:

```dart
import 'dart:convert' show utf8;

String text = 'Hello World!';
List<int> encoded = utf8.encode(text);
Uint8List data = Uint8List.fromList(encoded);

UploadTask task = FirebaseStorage.instance.ref('uploads/hello-world.text')
  .putData(data);

try {
  await task.onComplete;
} catch (e) {
  print(e);
}
```

To learn more about tasks, view the [Handling Tasks](#handling-tasks) documentataion.

### Adding Metadata

When uploading a file, you can specify metadata such as the content type, cache control and any custom properties for the file.

Whilst calling one of the upload methods, provide a [`SettableMetadata`](!firebase_storage_platform_interface.SettableMetadata) instance:

```dart
SettableMetadata metadata = SettableMetadata(
  cacheControl: 'max-age=60',
  customMetadata: <String, String>{
    'userId': 'ABC123',
  },
);

UploadTask task = FirebaseStorage.instance.ref('uploads/file-to-upload.png')
  .putFile(file, metadata);

try {
  await task.onComplete;
} catch (e) {
  print(e);
}
```

If a file is already present on the storage bucket, you can request the metadata by calling `getMetadata`:

```dart
FullMetadata task = await FirebaseStorage.instance.ref('uploads/file-to-upload.png')
  .getMetadata();
```

## Downloading Files

To physically download a file to the local device, you can call the [`writeToFile`](!firebase_storage.Reference.writeToFile) method on
any storage bucket reference. The location of where the file will be downloaded to is determined by the absolute path of the
[`File`](https://api.dart.dev/stable/2.9.2/dart-io/File-class.html) instance provided, for example:

```dart
import 'package:path_provider/path_provider.dart';

Directory appDocDir = await getApplicationDocumentsDirectory();
String filePath = '${appDocDir.absolute}/download-file.png';
File downloadPath = File(filePath);

DownloadTask task = FirebaseStorage.instance.ref('uploads/logo.png')
  .writeToFile(downloadPath);

try {
  await task.onComplete;
} catch (e) {
  print(e);
}
```

If a file already exists at the provided path, it will be overwritten.

To learn more about tasks, view the [Handling Tasks](#handling-tasks) documentataion.

## Handling Tasks

The uploading and downloading examples in the documentataion all return a `UploadTask` or `DownloadTask`. Tasks provide
the ability to control how the file is being uploaded/downloaded and provides metadata on the state of the task (e.g. progress status).

The simplest way to hook into when a task has completed is to wait for the `onComplete` Future to resolve, for example:

```dart
UploadTask task = FirebaseStorage.instance.ref('uploads/hello-world.text')
  .putString('Hello World');

try {
  await task.onComplete;
} on FirebaseException catch (e) {
  if (e.code == 'permission-denied') {
    print('User does not have permission to upload to this reference.');
  }
} catch (e) {
  print(e);
}
```

Although this can satisfy some use-cases, for larger files it is a better user experience if a progress indicator
can be shown. The tasks provides a stream of events, which emits a [`TaskSnapshot`](!firebase_storage.TaskSnapshot) each time
a notable event occurrs (e.g. bytes uploaded). The snapshot provides information about the state of the task along with the amount of
bytes that have been processed:

```dart
UploadTask task = FirebaseStorage.instance.ref('uploads/hello-world.text')
  .putFile(file); // A large 10mb file

task.snapshotEvents.listen((TaskSnapshot snapshot) {
  print('Task state: ${snapshot.state}');
  print('Progress: ${(snapshot.totalBytes/snapshot.bytesTransferred) * 100} %');
}, onError: (e) {
  print('Upload failed: $e');
});
```

The `state` property of a snapshot indicates a [`TaskState`](!firebase_storage_platform_interface.TaskState). The state can be one
of the following values:

- `TaskState.running` - Indicates the task is currently running.
- `TaskState.paused` - Indiciates the task is paused.
- `TaskState.complete` - The task has completed and no more events will be sent.

Using both `snapshotEvents` and `onComplete` together, or individually is supported - use whichever combination works for your application.

### Pause, resume and cancel

It is possible to pause/resume or cancel a task, by calling the `pause`, `resume` or `cancel` methods:

```dart
UploadTask task = FirebaseStorage.instance.ref('mountains.png').putFile(file);

// Pause the upload
bool paused = await task.pause();

// Resume the upload
bool resumed = await task.resume();

// Cancel the upload
bool cancelled = await task.cancel();
```

When calling `pause` or `resume`, any `snapshotEvents` listeners will be triggered with a new `TaskState`.

However, calling `cancel` will trigger the task to fail. Any Future or Stream listeners will recieve a `FirebaseException` instance
with a `canceled` code, for example:

```dart
UploadTask task = FirebaseStorage.instance.ref('mountains.png').putFile(file);

// Setup a Stream listener
task.snapshotEvents.listen((TaskSnapshot snapshot) {
  // Handle snapshot events...
}, onError: (e) {
  if (e.code == 'canceled') {
    print('The task has been canceled');
  }
});

// Cancel the task
await task.cancel();

// The Future will fail with a FirebaseException
try {
  await task.onComplete;
} on FirebaseException catch (e) {
   if (e.code == 'canceled') {
    print('The task has been canceled');
  }
}
```
