---
title: Cloud Messaging
sidebar_label: Usage
---

# Cloud Messaging

To start using the Cloud Messaging package within your project, import it at the top of your project files:

```dart
import 'package:cloud_messaging/cloud_messaging.dart';
```

Before using Messaging, you must first have ensured you have [initialized FlutterFire](../overview.mdx#initializing-flutterfire).

To create a new Messaging instance, call the [`instance`](!cloud_messaging.FirebaseMessaging.instance) getter on
[`FirebaseMessaging`](!cloud_messaging.FirebaseMessaging):

```dart
FirebaseMessaging messaging = FirebaseMessaging.instance;
```

Messaging only supports usage with the default Firebase App.

## Receiving messages

The Cloud Messaging package connects applications to the [Firebase Cloud Messaging (FCM)](https://firebase.google.com/docs/cloud-messaging)
service. You can send message payloads directly to devices at no cost. Each message payload can be up to 4KB in size, containing pre-defined
or custom data to suit your applications requirements.

Common use-cases for handling messages could be:

- Displaying a notification (see [Notifications](notifications.mdx)).
- Syncing message data silently on the device (e.g. via [shared_preferences](https://flutter.dev/docs/cookbook/persistence/key-value)).
- Updating the application's UI.

> To learn about how to send messages to devices from your own server setup, view the [Server Integration](server-integration.mdx) documentation.

Depending on the devices state, incoming messages are handled differently by the device and module. To understand these scenarios, it is first
important to establish the various states a device can be in:

| State          | Description                                                                                                                                                                                                                                      |
| -------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **Foreground** | When the application is open and in view.                                                                                                                                                                                                        |
| **Background** | When the application is open, however in the background. This typically occurs when the user has pressed the "home" button on the device, has switched to another app via the app switcher or has the application open on a different tab (web). |
| **Terminated** | When the device is locked or application is not active or running. The user can terminate an app by "swiping it away" via the app switcher UI on the device or closing a tab (web).                                                              |

There are a few preconditions which must be met before the application can receieve message payloads via FCM:

- The application must have opened at least once (to allow for registration with FCM).
- On mobile, if the user force quits the application from device settings, it must be manually reopened again.
- On iOS, you must have [correctly setup your project](ios-setup.mdx) to integrate with FCM.

### Request permission (iOS, Web)

On iOS & web, before FCM payloads can be recieved on your device, you must first ask the users permission. Android applications do not have to
request permission.

The package provides a simple API for requesting permission via the [`requestPermission`](!cloud_messaging.FirebaseMessaging.requestPermission) method.
This API accepts a number of named arguments which define the type of permissions you'd like to request, such as whether
your notifications can play a sound, read out messages via Siri, override the device preferences etc. By default,
the method requests sensible default permissions. Read the reference API to view the full list and descriptions of each permission.

To get started, call the method from your application (on iOS a native modal will be displayed, on web
the browsers native API flow will be triggered):

```dart
FirebaseMessaging messaging = FirebaseMessaging.instance;

NotificationSettings settings = await messaging.requestPermission(
  alert: true,
  announcement: false,
  badge: true,
  carPlay: false,
  criticalAlert: false,
  provisional: false,
  sound: true,
);

print('User granted permission: ${settings.authorizationStatus}');
```

The [`NotificationSettings`](!cloud_messaging_platform_interface.NotificationSettings) returned from
the request details information regarding the users decision.

The `authorizationStatus` property can return a value which can be used to determine the users decision:

- `authorized`: The user granted permission.
- `denied`: The user denied permission.
- `notDetermined`: The user has not yet chosen whether to grant permission.
- `provisional`: The user granted provisional permission (see [Provisional Permission](permissions#provisional-permission)).

> On Android `authorizationStatus` is always `authorized`.

The other properies on `NotificationSettings` return whether a specific permission is enabled, disabled or not supported on the current
device.

For further information, view the [Permissions](permissions.mdx) documentation.

## Handling messages

Once permission has been granted & the different types of state have been understood, your application can now start to handle the incoming
FCM payloads!

Each payload sent to a device can contain custom data and/or notification data. Data only messages are usually intended to be handled silently,
allowing your own custom logic to do _something_. Payloads containing [notification data](notifications.mdx) detected by the device and will attempt
to display a visible notification to the user (if permissions allows this). Both custom data and notification data can be combined into the same payload.

Based on your applications current state, incoming payloads require different implementations to handle them:

|                         | Foreground  | Background                              | Terminated                              |
| ----------------------- | ----------- | --------------------------------------- | --------------------------------------- |
| **Notification**        | `onMessage` | `onBackgroundMessage`                   | `onBackgroundMessage`                   |
| **Notification + Data** | `onMessage` | `onBackgroundMessage`                   | `onBackgroundMessage`                   |
| **Data**                | `onMessage` | `onBackgroundMessage` (**_see below_**) | `onBackgroundMessage` (**_see below_**) |

Data only messages are considered low priority by devices when your application is in the background or terminated, and will be
ignored. You can however explicially increase the priority by sending additional properties on the FCM payload:

- On Android, set the `priority` field to `high`.
- On Apple (iOS & MacOS), set the `content-available` field to `true`.

Since the sending of FCM payloads is custom to your own setup, it is best to read the official [FCM API reference](https://firebase.google.com/docs/cloud-messaging/concept-options) for your chosen
SDK.

### Foreground messages

To listen to messages whilst your application is in the foreground, hook onto the [`onMessage`](!cloud_messaging.FirebaseMessaging.onMessage) stream.

```dart
TODO example
```

The stream contains a [`RemoteMessage`](!cloud_messaging_platform_interface.RemoteMessage), detailing
various information about the payload, such as where it was from, the unique ID, sent time, whether it contained
a notification & more.

Since the message was retrieved whilst your application is in the foreground, you can directly access your Flutter
applications state & context.

### Background & Terminated messages

Handling messages whilst your application is in the background or in a terminated state is a little different. Messages can
be handled via the [`onBackgroundMessage`](!cloud_messaging.FirebaseMessaging.onBackgroundMessage) handler. When recieved, an
isolate is spawned allowing you to handle messages even when your application is not running.

There are a few things to keep in mind about your background message handler:

1. It must not be an anonymous function.
2. It must be a top-level function (e.g. not a class method).

```dart
TODO example

BackgroundMessageHandler backgroundMessageHandler = (RemoteMessage message) {
  // implement background message logic
};

main() {
  FirebaseMessaging.onBackgroundMessage(backgroundMessageHandler);
  runApp(MyApp());
}
```

Since the handler runs in it's own isolate outside of your applications context, it is not possible to update
application state or execute any UI impacting logic. You can however perform network calls, update device storage etc.

It also also recommended to complete your logic as soon as possible. Running long intensive tasks impacts device performance
and may cause the OS to terminate the process. If tasks run for longer than 60 seconds, the device may automatically kill the process.

## Topics

Topics are a mechanism which allow a device to subscribe and unsubscribe from named PubSub channels, all managed via FCM.
Rather than sending a message to a specific device by FCM token, you can instead send a message to a topic and any devices
subscribed to that topic will receive the message.

Topics allow you to simplify FCM server integration as you do not need to keep a store of device tokens. There are however some things to keep in mind about topics:

- Messages sent to topics should not contain sensitive or private information. Do not create a topic for a specific user to subscribe to.
- Topic messaging supports unlimited subscriptions for each topic.
- One app instance can be subscribed to no more than 2000 topics.
- The frequency of new subscriptions is rate-limited per project. If you send too many subscription requests in a short period of time, FCM servers will respond with a 429 RESOURCE_EXHAUSTED ("quota exceeded") response. Retry with exponential backoff.
- A server integration can send a single message to multiple topics at once. This however is limited to 5 topics.

To learn more about how to send messages to devices subscribed to topics, view the [Send messages to topics](server-integration#send-messages-to-topics) documentation.

### Subscribing to topics

To subscribe a device, call the [`subscribeToTopic`](!cloud_messaging.FirebaseMessaging.subscribeToTopic) method with the topic name:

```dart
await FirebaseMessaging.instance.subscribeToTopic('weather');
```

### Unsubscribing from topics

To unsubscribe from a topic, call the [`unsubscribeFromTopic`](!cloud_messaging.FirebaseMessaging.unsubscribeFromTopic) method with the topic name:

```dart
await FirebaseMessaging.instance.unsubscribeFromTopic('weather');
```
